<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Avocado Ibuprofen Paint</title>
<style>
/* General page setup */
body { 
  margin: 0; 
  padding: 20px; 
  font-family: Arial, sans-serif; 
  background: #f0f0f0; 
}

/* App title */
.app-title {
  font-family: Papyrus, fantasy; /* Papyrus font, fallback to fantasy */
  font-size: 24px;
  font-weight: bold;
  text-align: left;
  margin-bottom: 5px;
}

/* Container holding toolbar + canvas */
.container {
  display: flex;
  gap: 10px;
  padding: 10px;
  justify-content: flex-start; /* align to left */
}

/* Toolbar styling */
.toolbar { 
  background: #fff;               /* white background */
  border: 2px solid #000;        /* black border */
  color: #000;                    /* all text black */
  padding: 20px;
  border-radius: 0px;
  width: 250px;                   /* fixed width */
  height: 1020px;                 /* match canvas height */
  display: flex;
  flex-direction: column;
  gap: 20px;
  box-sizing: border-box;
}

/* Removed logo box */
.toolbar .logo {
  display: none; /* no longer needed */
}

/* Tool groups minimal styling */
.tool-group {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.tool-group h3 {
  margin: 0;
  font-size: 14px;
  color: #000; /* black text */
}

/* Color buttons */
.color-section {
  display: flex;
  gap: 10px;
  align-items: center;
}

.color-btn {
  width: 30px;
  height: 30px;
  border: 2px solid #000;
  cursor: pointer;
  border-radius: 3px;
}

.color-btn.active {
  border-color: #000;
  border-width: 3px;
}

.black { background: #000; }
.white { background: #fff; }

/* Brush selector */
.brush-selector {
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.brush-btn {
  padding: 6px 10px;
  border: 2px solid #000;
  cursor: pointer;
  border-radius: 3px;
  background: #fff;
  color: #000;
  font-size: 12px;
  font-weight: bold;
  text-align: left;
  transition: all 0.2s;
}

.brush-btn:hover { background: #f0f0f0; }
.brush-btn.active { border-color: #000; background: #e6e6e6; }

/* Brush size controls */
.brush-size {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.size-controls {
  display: flex;
  align-items: center;
  gap: 10px;
}

.brush-preview {
  width: 40px;
  height: 40px;
  border: 1px solid #000;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 3px;
}

.brush-dot { 
  background: #000;
  border-radius: 50%; 
}

/* Action buttons */
.actions {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

button { 
  padding: 5px 8px;
  border: 2px solid #000;
  background: #000;
  color: #fff;
  cursor: pointer;
  border-radius: 3px;
  font-size: 12px;
  transition: background 0.2s;
}

button:hover { background: #f0f0f0; }

/* Canvas container */
.canvas-container {
  border: 2px solid #333; 
  flex: 0 0 auto;   /* do not grow/shrink */
}

#canvas { 
  display: block; 
  cursor: crosshair; 
  width: 1080px;
  height: 1080px;
}

/* Range input styling */
input[type="range"] { width: 150px; }
label { font-weight: bold; font-size: 12px; color: #000; }
</style>

</head>
<body>
<div class="app-title">Avocado Ibuprofen Paint 1.2</div>
<div class="container">
  <div class="toolbar">
    <div class="tool-group">
      <h3>Colors</h3>
      <div class="color-section">
        <div class="color-btn black active" data-color="#000000" title="Black"></div>
        <div class="color-btn white" data-color="#ffffff" title="White"></div>
      </div>
    </div>
    
    <div class="tool-group">
      <h3>Brushes</h3>
      <div class="brush-selector">
        <div class="brush-btn active" data-brush="smooth">Simple Brush</div>
        <div class="brush-btn" data-brush="soft">Soft Brush</div>
        <div class="brush-btn" data-brush="texture">Circular Splatter</div>
        <div class="brush-btn" data-brush="scatter">Pixel Brush</div>
        <div class="brush-btn" data-brush="halftone">Solitaire Brush</div>
        <div class="brush-btn" data-brush="noise">Venetian Brush</div>
        <div class="brush-btn" data-brush="glitch">Spiral Brush</div>
        <div class="brush-btn" data-brush="pixel">Mosaic Brush</div>
        <div class="brush-btn" data-brush="spiral">Tornado Brush</div>
        <div class="brush-btn" data-brush="cross">Cross Brush</div>
        <div class="brush-btn" data-brush="displace">Spiral Smear</div>
        <div class="brush-btn" data-brush="speed">Fast Forward</div>
        <div class="brush-btn" data-brush="ripple">Ripple Brush</div>
        <div class="brush-btn" data-brush="smear">Palette Knife</div>
        <div class="brush-btn" data-brush="bucket">Fill</div>
        <div class="brush-btn" data-brush="bucketHalf">Halftone Brush</div>
      </div>
    </div>
    
    <div class="tool-group">
      <h3>Brush Size</h3>
      <div class="brush-size">
        <div class="size-controls">
          <input type="range" id="brushSize" min="1" max="200" value="10">
          <div class="brush-preview"><div class="brush-dot" id="brushPreview"></div></div>
        </div>
        <label id="sizeLabel">Size: 10</label>
      </div>
    </div>
    
    <div class="tool-group">
      <h3>Actions</h3>
      <div class="actions">
        <button onclick="undo()">Undo (u)</button>
        <button onclick="clearCanvas()">Clear Canvas (backspace)</button>
        <button onclick="invertAndThreshold()">Invert + Threshold (i)</button>
        <button onclick="saveImage()">Save PNG (s)</button>
      </div>
    </div>
  </div>
  
  <div class="canvas-container">
    <canvas id="canvas" width="1080" height="1080"></canvas>
  </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const brushSizeSlider = document.getElementById('brushSize');
const brushPreview = document.getElementById('brushPreview');
const sizeLabel = document.getElementById('sizeLabel');
let isDrawing = false;
let currentColor = '#000000';
let currentBrushSize = 10;
let currentBrush = 'smooth';
let lastX = 0, lastY = 0, lastTime = 0;
let undoStack = [];
const MAX_UNDO = 20;

ctx.fillStyle = 'white';
ctx.fillRect(0, 0, canvas.width, canvas.height);

function saveState() {
  if (undoStack.length >= MAX_UNDO) undoStack.shift();
  undoStack.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
}

function undo() {
  if (undoStack.length > 0) {
    const prev = undoStack.pop();
    ctx.putImageData(prev, 0, 0);
  }
}

// Color buttons
document.querySelectorAll('.color-btn').forEach(btn => {
  btn.addEventListener('click', function() {
    document.querySelector('.color-btn.active').classList.remove('active');
    this.classList.add('active');
    currentColor = this.dataset.color;
  });
});

// Brush buttons
document.querySelectorAll('.brush-btn').forEach(btn => {
  btn.addEventListener('click', function() {
    document.querySelector('.brush-btn.active').classList.remove('active');
    this.classList.add('active');
    currentBrush = this.dataset.brush;
  });
});

brushSizeSlider.addEventListener('input', function() {
  currentBrushSize = this.value;
  sizeLabel.textContent = `Size: ${this.value}`;
  updateBrushPreview();
});

function updateBrushPreview() {
  const size = Math.min(currentBrushSize / 4, 30);
  brushPreview.style.width = size + 'px';
  brushPreview.style.height = size + 'px';
}

// --- Brushes ---
function drawSmooth(x, y) {
  ctx.fillStyle = currentColor;
  ctx.beginPath();
  ctx.arc(x, y, currentBrushSize/2, 0, Math.PI*2);
  ctx.fill();
}

function drawSoft(x, y) {
  const gradient = ctx.createRadialGradient(x, y, 0, x, y, currentBrushSize);
  gradient.addColorStop(0, currentColor);
  gradient.addColorStop(1, 'transparent');
  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.arc(x, y, currentBrushSize, 0, Math.PI*2);
  ctx.fill();
}

function drawTexture(x, y) {
  const r = currentBrushSize;
  const now = Date.now();
  let speed = 1;
  if (lastX !== null && lastY !== null && lastTime !== null) {
    const dx = x - lastX, dy = y - lastY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const dt = Math.max(1, now - lastTime);
    speed = dist / dt * 10;
  }
  const particleCount = Math.floor(r * 15 * (1 + speed));
  const maxDist = r * (3 + speed * 2);
  for (let i = 0; i < particleCount; i++) {
    const angle = Math.random() * Math.PI * 2;
    const dist = Math.pow(Math.random(), 0.5) * maxDist;
    const sx = x + Math.cos(angle) * dist;
    const sy = y + Math.sin(angle) * dist;
    const size = Math.random() * (2 + speed * 2) + 2;
    const color = Math.random() < 0.5 ? "black" : "white";
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(sx, sy, size, 0, Math.PI * 2);
    ctx.fill();
  }
  lastX = x;
  lastY = y;
  lastTime = now;
}

function drawScatter(x, y) {
  // Pixel size now scales directly with the brush size
  const pixelSize = Math.max(2, currentBrushSize / 2); 
  const gridX = Math.floor(x / pixelSize) * pixelSize;
  const gridY = Math.floor(y / pixelSize) * pixelSize;
  const radius = currentBrushSize / 2;
  
  for (let px = gridX - radius; px < gridX + radius; px += pixelSize) {
    for (let py = gridY - radius; py < gridY + radius; py += pixelSize) {
      if ((px - x) * (px - x) + (py - y) * (py - y) <= radius * radius) {
        ctx.fillStyle = currentColor;
        ctx.fillRect(px, py, pixelSize, pixelSize);
      }
    }
  }
}


function drawHalftone(x, y) {
  if (drawHalftone.prevX === undefined || drawHalftone.prevY === undefined) {
    drawHalftone.prevX = x;
    drawHalftone.prevY = y;
    return;
  }
  const dx = x - drawHalftone.prevX;
  const dy = y - drawHalftone.prevY;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const strokes = Math.max(5, Math.min(50, Math.floor(dist * 2)));
  for (let i = 0; i < strokes; i++) {
    const t = i / strokes;
    const px = drawHalftone.prevX + dx * t;
    const py = drawHalftone.prevY + dy * t;
    const jitter = Math.random() * (dist / 3 + 1);
    const jx = px + (Math.random() - 0.5) * jitter;
    const jy = py + (Math.random() - 0.5) * jitter;
    const color = Math.random() < 0.5 ? "#000000" : "#FFFFFF";
    ctx.fillStyle = color;
    ctx.fillRect(jx, jy, currentBrushSize, currentBrushSize);
  }
  drawHalftone.prevX = x;
  drawHalftone.prevY = y;
}

function resetHalftone() {
  drawHalftone.prevX = undefined;
  drawHalftone.prevY = undefined;
}

function drawNoise(x, y) {
  const glitchWidth = currentBrushSize;
  const glitchHeight = 2;
  for (let i = 0; i < 5; i++) {
    const offsetX = (Math.random() - 0.5) * 20;
    const offsetY = (Math.random() - 0.5) * 20;
    ctx.fillStyle = currentColor;
    ctx.fillRect(x + offsetX, y + offsetY, glitchWidth + Math.random() * 10, glitchHeight);
    ctx.fillRect(x + offsetX, y + offsetY + 5, Math.random() * glitchWidth, glitchHeight);
  }
}

function drawGlitch(x, y) {
  ctx.strokeStyle = currentColor;
  ctx.beginPath();
  for (let i = 0; i < 20; i++) {
    const angle = 0.3 * i;
    const radius = currentBrushSize * 0.2 * i;
    ctx.lineTo(x + radius * Math.cos(angle), y + radius * Math.sin(angle));
  }
  ctx.stroke();
}

function drawPixel(x, y) {
  const size = currentBrushSize;
  // Make pixel blocks scale with brush size (minimum 2px so they're always visible)
  const chunk = Math.max(2, Math.floor(size / 4));

  for (let i = 0; i < size; i += chunk) {
    for (let j = 0; j < size; j += chunk) {
      const color = Math.random() < 0.5 ? "#000000" : "#FFFFFF";
      ctx.fillStyle = color;
      ctx.fillRect(x + i, y + j, chunk, chunk);
    }
  }
}


function drawSpiral(x, y) {
  const r = currentBrushSize * 2;
  const img = ctx.getImageData(x - r, y - r, r * 2, r * 2);
  const data = img.data;
  const cx = img.width / 2, cy = img.height / 2;
  for (let py = 0; py < img.height; py++) {
    for (let px = 0; px < img.width; px++) {
      const dx = px - cx, dy = py - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx) + (dist / 40);
      const sx = Math.round(cx + Math.cos(angle) * dist);
      const sy = Math.round(cy + Math.sin(angle) * dist);
      if (sx >= 0 && sx < img.width && sy >= 0 && sy < img.height) {
        const idx = (py * img.width + px) * 4;
        const sidx = (sy * img.width + sx) * 4;
        data[idx] = data[sidx];
        data[idx + 1] = data[sidx + 1];
        data[idx + 2] = data[sidx + 2];
      }
    }
  }
  ctx.putImageData(img, x - r, y - r);
}

function drawCross(x, y) {
  ctx.strokeStyle = currentColor;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x - currentBrushSize, y);
  ctx.lineTo(x + currentBrushSize, y);
  ctx.moveTo(x, y - currentBrushSize);
  ctx.lineTo(x, y + currentBrushSize);
  ctx.stroke();
}

function drawDisplace(x, y) {
  const r = currentBrushSize;
  const img = ctx.getImageData(x - r, y - r, r * 2, r * 2);
  const data = img.data;
  for (let py = 0; py < img.height; py++) {
    for (let px = 0; px < img.width; px++) {
      const idx = (py * img.width + px) * 4;
      const dx = Math.sin(py / 4) * 2;
      const dy = Math.cos(px / 4) * 2;
      const sx = Math.min(img.width - 1, Math.max(0, px + dx));
      const sy = Math.min(img.height - 1, Math.max(0, py + dy));
      const sidx = (Math.round(sy) * img.width + Math.round(sx)) * 4;
      data[idx] = data[sidx];
      data[idx + 1] = data[sidx + 1];
      data[idx + 2] = data[sidx + 2];
    }
  }
  ctx.putImageData(img, x - r, y - r);
}

function drawSpeed(x, y) {
  const r = currentBrushSize * 2;
  const img = ctx.getImageData(x - r, y - r, r * 2, r * 2);
  const data = img.data;
  for (let py = 0; py < img.height; py++) {
    if (Math.random() < 0.1) {
      const shift = Math.floor((Math.random() - 0.5) * 20);
      for (let px = 0; px < img.width; px++) {
        const idx = (py * img.width + px) * 4;
        const sx = Math.min(img.width - 1, Math.max(0, px + shift));
        const sidx = (py * img.width + sx) * 4;
        data[idx] = data[sidx];
        data[idx + 1] = data[sidx + 1];
        data[idx + 2] = data[sidx + 2];
      }
    }
  }
  ctx.putImageData(img, x - r, y - r);
}

function drawRipple(x, y) {
  const r = currentBrushSize * 2;
  const img = ctx.getImageData(x - r, y - r, r * 2, r * 2);
  const data = img.data;
  for (let py = 0; py < img.height; py++) {
    for (let px = 0; px < img.width; px++) {
      const idx = (py * img.width + px) * 4;
      const dx = px - r, dy = py - r;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const offset = Math.sin(dist / 5) * 2;
      const sx = Math.min(img.width - 1, Math.max(0, px + dx * offset / dist));
      const sy = Math.min(img.height - 1, Math.max(0, py + dy * offset / dist));
      const sidx = (Math.round(sy) * img.width + Math.round(sx)) * 4;
      data[idx] = data[sidx];
      data[idx + 1] = data[sidx + 1];
      data[idx + 2] = data[sidx + 2];
    }
  }
  ctx.putImageData(img, x - r, y - r);
}

function drawSmear(x, y) {
  if (!lastX || !lastY) return;
  const dx = x - lastX, dy = y - lastY;
  const len = Math.sqrt(dx * dx + dy * dy);
  const steps = Math.max(4, len / 2);
  const img = ctx.getImageData(lastX, lastY, dx || 1, dy || 1);
  for (let i = 0; i < steps; i++) {
    ctx.putImageData(img, lastX + dx * (i / steps), lastY + dy * (i / steps));
  }
}

function drawBucket(x, y) {
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data;

  const width = canvas.width;
  const height = canvas.height;

  // Get target pixel index
  const targetIndex = (Math.floor(y) * width + Math.floor(x)) * 4;

  // Convert target color to pure black or white
  const targetGray = data[targetIndex] * 0.299 + data[targetIndex + 1] * 0.587 + data[targetIndex + 2] * 0.114;
  const targetValue = targetGray > 127 ? 255 : 0;

  // Determine fill value from currentColor
  const fillValue = currentColor === '#000000' ? 0 : 255;

  // If trying to fill with same value â†’ do nothing
  if (targetValue === fillValue) return;

  // Flood fill
  const visited = new Uint8Array(width * height);
  const stack = [Math.floor(x) + Math.floor(y) * width];

  while (stack.length > 0) {
    const pos = stack.pop();
    if (visited[pos]) continue;
    visited[pos] = 1;

    const px = pos % width;
    const py = Math.floor(pos / width);
    if (px < 0 || px >= width || py < 0 || py >= height) continue;

    const idx = pos * 4;

    // Convert this pixel to black/white and check match
    const gray = data[idx] * 0.299 + data[idx + 1] * 0.587 + data[idx + 2] * 0.114;
    const val = gray > 127 ? 255 : 0;

    if (val !== targetValue) continue;

    // Fill with chosen value
    data[idx] = data[idx + 1] = data[idx + 2] = fillValue;
    data[idx + 3] = 255;

    // Push neighbors
    if (px > 0) stack.push(pos - 1);
    if (px < width - 1) stack.push(pos + 1);
    if (py > 0) stack.push(pos - width);
    if (py < height - 1) stack.push(pos + width);
  }

  ctx.putImageData(imageData, 0, 0);
}



function drawBucketHalf(x, y) {
  const r = currentBrushSize * 3;
  ctx.save();
  ctx.fillStyle = currentColor;
  for (let yy = -r; yy < r; yy += currentBrushSize / 2) {
    for (let xx = -r; xx < r; xx += currentBrushSize / 2) {
      if ((xx + yy) % currentBrushSize < currentBrushSize / 2) {
        ctx.beginPath();
        ctx.arc(x + xx, y + yy, currentBrushSize / 4, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }
  ctx.restore();
}

// --- Main draw ---
function startDrawing(e) {
  saveState();
  isDrawing = true;
  const rect = canvas.getBoundingClientRect();
  lastX = (e.clientX - rect.left) * (canvas.width / rect.width);
  lastY = (e.clientY - rect.top) * (canvas.height / rect.height);
  draw(e);
}

function draw(e) {
  if (!isDrawing) return;
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (canvas.width / rect.width);
  const y = (e.clientY - rect.top) * (canvas.height / rect.height);
  
  switch(currentBrush) {
    case 'smooth': drawSmooth(x, y); break;
    case 'soft': drawSoft(x, y); break;
    case 'texture': drawTexture(x, y); break;
    case 'scatter': drawScatter(x, y); break;
    case 'halftone': drawHalftone(x, y); break;
    case 'noise': drawNoise(x, y); break;
    case 'glitch': drawGlitch(x, y); break;
    case 'pixel': drawPixel(x, y); break;
    case 'spiral': drawSpiral(x, y); break;
    case 'cross': drawCross(x, y); break;
    case 'displace': drawDisplace(x, y); break;
    case 'speed': drawSpeed(x, y); break;
    case 'ripple': drawRipple(x, y); break;
    case 'smear': drawSmear(x, y); break;
    case 'bucket': drawBucket(x, y); break;
    case 'bucketHalf': drawBucketHalf(x, y); break;
  }
  lastX = x; 
  lastY = y;
}

function stopDrawing() { 
  isDrawing = false; 
  lastX = lastY = 0; 
  resetHalftone();
}

canvas.addEventListener('mousedown', startDrawing);
canvas.addEventListener('mousemove', draw);
canvas.addEventListener('mouseup', stopDrawing);
canvas.addEventListener('mouseout', stopDrawing);

// Utils
function clearCanvas() { 
  saveState(); 
  ctx.fillStyle = 'white'; 
  ctx.fillRect(0, 0, canvas.width, canvas.height); 
}

function invertAndThreshold() { 
  const img = ctx.getImageData(0, 0, canvas.width, canvas.height); 
  const d = img.data; 
  for(let i = 0; i < d.length; i += 4) {
    const g = d[i] * 0.3 + d[i + 1] * 0.6 + d[i + 2] * 0.1;
    const t = g > 127 ? 0 : 255;
    d[i] = d[i + 1] = d[i + 2] = t;
  } 
  ctx.putImageData(img, 0, 0);
} 

function saveImage() { 
  const a = document.createElement('a'); 
  a.download = 'drawing.png'; 
  a.href = canvas.toDataURL(); 
  a.click(); 
}
// --- Keyboard Shortcuts (single letters) ---
document.addEventListener('keydown', function (e) {
  // Ignore if typing in an input/textarea
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

  switch (e.key.toLowerCase()) {
    case 'u': // Undo
      e.preventDefault();
      undo();
      break;

    case 's': // Save
      e.preventDefault();
      saveImage();
      break;

    case 'i': // Invert
      e.preventDefault();
      invertAndThreshold();
      break;

    case 'backspace': // Clear canvas
      e.preventDefault();
      clearCanvas();
      break;
  }
});



updateBrushPreview();
</script>
</body>
</html>
