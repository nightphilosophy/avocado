<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Avocado Ibuprofen Paint</title>
<style>
/* General page setup */
body {
  margin: 0;
  padding: 20px;
  font-family: Arial, sans-serif;
  background: #f0f0f0;
}

/* App title */
.app-title {
  font-family: Papyrus, fantasy; /* Papyrus font, fallback to fantasy */
  font-size: 24px;
  font-weight: bold;
  text-align: left;
  margin-bottom: 5px;
}

/* Container holding toolbar + canvas */
.container {
  display: flex;
  gap: 10px;
  padding: 10px;
  justify-content: flex-start; /* align to left */
}

/* Left Toolbar styling */
.toolbar {
  background: #fff;               /* white background */
  border: 2px solid #000;        /* black border */
  color: #000;                    /* all text black */
  padding: 10px;
  border-radius: 0px;
  width: 250px;                   /* fixed width */
  height: 1030px;                 /* match canvas height */
  display: flex;
  flex-direction: column;
  gap: 20px;
  box-sizing: border-box;
}

/* Right Toolbar styling */
.right-toolbar {
  background: #fff;
  border: 2px solid #000;
  color: #000;
  padding: 10px;
  border-radius: 0px;
  width: 60px; /* Narrower width for single-symbol tools */
  height: 260px; /* Match canvas height */
  display: flex;
  flex-direction: column;
  gap: 10px;
  box-sizing: border-box;
  justify-content: flex-start;
  align-items: center;
}

/* Tool groups minimal styling */
.tool-group {
  display: flex;
  flex-direction: column;
  gap: 5px; /* Reduced gap to bring symbols closer */
}

.tool-group h3 {
  margin: 0;
  font-size: 14px;
  color: #000; /* black text */
}

/* Color buttons */
.color-section {
  display: flex;
  gap: 10px;
  align-items: center;
}

.color-btn {
  width: 30px;
  height: 30px;
  border: 2px solid #000;
  cursor: pointer;
  border-radius: 3px;
}

.color-btn.active {
  border-color: #000;
  border-width: 3px;
}

.black { background: #000; }
.white { background: #fff; }

/* Brush selector */
.brush-selector {
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.brush-btn {
  padding: 6px 10px;
  border: 2px solid #000;
  cursor: pointer;
  border-radius: 3px;
  background: #fff;
  color: #000;
  font-size: 12px;
  font-weight: bold;
  text-align: left;
  transition: all 0.2s;
}

.brush-btn:hover { background: #f0f0f0; }
.brush-btn.active { border-color: #000; background: #e6e6e6; }

/* Brush size controls */
.brush-size {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.size-controls {
  display: flex;
  align-items: center;
  gap: 10px;
}

.brush-preview {
  width: 40px;
  height: 40px;
  border: 1px solid #000;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 3px;
}

.brush-dot {
  background: #000;
  border-radius: 50%;
}

/* Action buttons */
.actions {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

button {
  padding: 5px 8px;
  border: 2px solid #000;
  background: #000;
  color: #fff;
  cursor: pointer;
  border-radius: 3px;
  font-size: 12px;
  transition: background 0.2s;
}

button:hover { background: #f0f0f0; }

/* New symbol tool buttons */
.symbol-tool {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 5px;
  font-size: 24px;
  font-weight: bold;
  cursor: pointer;
  transition: background 0.2s;
  border: 2px solid #000; /* Added light border */
  padding: 5px;
  border-radius: 3px;
}

.symbol-tool:hover {
  background: #e6e6e6;
}

.symbol-tool.active {
  background: #e6e6e6;
  border: 2px solid #000; /* Made active border more prominent */
}

/* Canvas container */
.canvas-container {
  border: 2px solid #333;
  flex: 0 0 auto;   /* do not grow/shrink */
}

#canvas {
  display: block;
  cursor: crosshair;
  width: 1080px;
  height: 1080px;
}

/* Range input styling */
input[type="range"] { width: 150px; }
label { font-weight: bold; font-size: 12px; color: #000; }

.user-note {
  font-size: 12px;
  color: #000;
  font-family: Arial, sans-serif;
  text-align: left;
  margin-top: 20px;
}
</style>

</head>
<body>
<div class="app-title">Avocado Ibuprofen Paint</div>
<div class="container">
  <!-- Existing Left Toolbar -->
  <div class="toolbar">
    <div class="tool-group">
      <h3>Colors</h3>
      <div class="color-section">
        <div class="color-btn black active" data-color="#000000" title="Black"></div>
        <div class="color-btn white" data-color="#ffffff" title="White"></div>
      </div>
    </div>

    <div class="tool-group">
      <h3>Brushes</h3>
      <div class="brush-selector">
        <div class="brush-btn active" data-brush="smooth">Simple Brush</div>
        <div class="brush-btn" data-brush="soft">Dotted Brush</div>
        <div class="brush-btn" data-brush="texture">Circular Splatter</div>
        <div class="brush-btn" data-brush="scatter">Pixel Brush</div>
        <div class="brush-btn" data-brush="halftone">Solitaire Brush</div>
        <div class="brush-btn" data-brush="noise">Venetian Brush</div>
        <div class="brush-btn" data-brush="glitch">Spiral Brush</div>
        <div class="brush-btn" data-brush="pixel">Mosaic Brush</div>
        <div class="brush-btn" data-brush="spiral">Tornado Brush</div>
        <div class="brush-btn" data-brush="cross">Cross Brush</div>
        <div class="brush-btn" data-brush="displace">Spiral Smear</div>
        <div class="brush-btn" data-brush="speed">Fast Forward</div>
        <div class="brush-btn" data-brush="ripple">Ripple Brush</div>
        <div class="brush-btn" data-brush="smear">Palette Knife</div>
        <div class="brush-btn" data-brush="bucket">Fill</div>
        <div class="brush-btn" data-brush="bucketHalf">Halftone Brush</div>
      </div>
    </div>

    <div class="tool-group">
      <h3>Brush Size (⬆, ⬇)</h3>
      <div class="brush-size">
        <div class="size-controls">
          <input type="range" id="brushSize" min="1" max="200" value="10">
          <div class="brush-preview"><div class="brush-dot" id="brushPreview"></div></div>
        </div>
        <label id="sizeLabel">Size: 10</label>
      </div>
    </div>

    <div class="tool-group">
      <h3>Actions</h3>
      <div class="actions">
        <button onclick="undo()">Undo (u)</button>
        <button onclick="clearCanvas()">Clear Canvas (backspace)</button>
        <button onclick="importImage()">Import Image</button>
        <button onclick="invertAndThreshold()">Invert + Threshold (i)</button>
        <input type="file" id="imageInput" accept="image/*" style="display: none;" />
        <button onclick="saveImage()">Save PNG (s)</button>
      </div>
    </div>
  <div class="user-note">
  Please post your images on instagram or bluesky with the hashtag #avocadopaint – I'd love to see what you made!
  </div>
  </div>

  <div class="canvas-container">
    <canvas id="canvas" width="1080" height="1080"></canvas>
  </div>

  <!-- New Right Toolbar -->
  <div class="right-toolbar">
    <div class="tool-group">
      <div class="symbol-tool" data-tool="socrates" title="Socrates">⚙</div>
      <div class="symbol-tool" data-tool="plato" title="Plato">◘</div>
      <div class="symbol-tool" data-tool="aristotle" title="Aristotle">⌘</div>
      <div class="symbol-tool" data-tool="descartes" title="Descartes">⏼</div>
      <div class="symbol-tool" data-tool="nietzsche" title="Nietzsche">▓</div>
    </div>
  </div>  

</div>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const brushSizeSlider = document.getElementById('brushSize');
const brushPreview = document.getElementById('brushPreview');
const sizeLabel = document.getElementById('sizeLabel');
let isDrawing = false;
let currentColor = '#000000';
let currentBrushSize = 10;
let currentBrush = 'smooth';
let lastX = 0, lastY = 0, lastTime = 0;
let undoStack = [];
const MAX_UNDO = 20;

ctx.fillStyle = 'white';
ctx.fillRect(0, 0, canvas.width, canvas.height);

function saveState() {
  if (undoStack.length >= MAX_UNDO) undoStack.shift();
  undoStack.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
}

function undo() {
  if (undoStack.length > 0) {
    const prev = undoStack.pop();
    ctx.putImageData(prev, 0, 0);
  }
}

// Color buttons
document.querySelectorAll('.color-btn').forEach(btn => {
  btn.addEventListener('click', function() {
    document.querySelector('.color-btn.active').classList.remove('active');
    this.classList.add('active');
    currentColor = this.dataset.color;
  });
});

// Brush buttons (left toolbar)
document.querySelectorAll('.brush-btn').forEach(btn => {
  btn.addEventListener('click', function() {
    // Remove active state from all brush buttons and symbol tools
    document.querySelectorAll('.brush-btn.active').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.symbol-tool.active').forEach(b => b.classList.remove('active'));
    
    this.classList.add('active');
    currentBrush = this.dataset.brush;
  });
});

// Symbol tool buttons (right toolbar)
document.querySelectorAll('.symbol-tool').forEach(btn => {
  btn.addEventListener('click', function() {
    // Remove active state from all brush buttons and symbol tools
    document.querySelectorAll('.brush-btn.active').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.symbol-tool.active').forEach(b => b.classList.remove('active'));
    
    this.classList.add('active');
    currentBrush = this.dataset.tool;
  });
});

brushSizeSlider.addEventListener('input', function() {
  currentBrushSize = this.value;
  sizeLabel.textContent = `Size: ${this.value}`;
  updateBrushPreview();
});

function updateBrushPreview() {
  const size = Math.min(currentBrushSize / 4, 30);
  brushPreview.style.width = size + 'px';
  brushPreview.style.height = size + 'px';
}

// --- Brushes ---
function drawSmooth(x, y) {
  const dx = x - lastX;
  const dy = y - lastY;
  const distance = Math.sqrt(dx * dx + dy * dy);
  const steps = Math.ceil(distance / (currentBrushSize / 2));

  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    const ix = lastX + dx * t;
    const iy = lastY + dy * t;

    ctx.fillStyle = currentColor;
    ctx.beginPath();
    ctx.arc(ix, iy, currentBrushSize / 2, 0, Math.PI * 2);
    ctx.fill();
  }
}


function drawSoft(x, y) {
  const dx = x - lastX;
  const dy = y - lastY;
  const distance = Math.sqrt(dx * dx + dy * dy);
  const steps = Math.ceil(distance / (currentBrushSize * 1.5)); // Fewer steps for a more distinct dotty effect

  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    const ix = lastX + dx * t;
    const iy = lastY + dy * t;

    // Simple dot with no gradient for clear circular dots
    ctx.fillStyle = currentColor;
    ctx.beginPath();
    ctx.arc(ix, iy, currentBrushSize / 3, 0, Math.PI * 2); // Smaller dots for clearer "dotty" look
    ctx.fill();
  }
}



function drawTexture(x, y) {
  const r = currentBrushSize;
  const now = Date.now();
  let speed = 1;
  let dx = 0, dy = 0;

  if (lastX !== null && lastY !== null && lastTime !== null) {
    dx = x - lastX;
    dy = y - lastY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const dt = Math.max(1, now - lastTime);
    speed = dist / dt * 10;
  }

  const direction = Math.atan2(dy, dx);
  const speedFactor = Math.min(speed, 10); // cap speed to avoid chaos overload
  const baseCount = r * 3;
  const particleCount = Math.min(180, Math.floor(baseCount * (1 + speedFactor * 0.3)));

  const maxDist = r * (1 + speedFactor * 0.5);
  
  for (let i = 0; i < particleCount; i++) {
    let angle = direction + (Math.random() - 0.5) * Math.PI; // biased toward movement direction
    const chaos = Math.random();

    // Distances: closer if slow, wilder if fast
    const dist = Math.pow(Math.random(), 0.5) * maxDist;

    let sx = x + Math.cos(angle) * dist;
    let sy = y + Math.sin(angle) * dist;

    // Occasionally throw particles BEHIND the movement
    if (chaos > 0.95) {
      const reverseAngle = direction + Math.PI + (Math.random() - 0.5) * 0.5;
      const backDist = Math.random() * r * 0.5;
      sx = x + Math.cos(reverseAngle) * backDist;
      sy = y + Math.sin(reverseAngle) * backDist;
    }

    // Particle size: random, but gets bigger with speed
    let size = Math.pow(Math.random(), 0.8) * (r * 0.25 + speedFactor * 0.4) + 0.3;

    // Occasionally make a big splat
    if (chaos < 0.03) size *= 3;

    // Occasionally sharp line particle
    if (chaos < 0.015) {
      const lineLength = Math.random() * 8 + 4;
      const lineAngle = angle + (Math.random() - 0.5) * 0.3;
      const ex = sx + Math.cos(lineAngle) * lineLength;
      const ey = sy + Math.sin(lineAngle) * lineLength;
      ctx.strokeStyle = Math.random() < 0.5 ? "#000" : "#FFF";
      ctx.lineWidth = Math.random() * 2 + 0.5;
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(ex, ey);
      ctx.stroke();
      continue; // skip arc for this one
    }

    // Black or white particles only
    ctx.fillStyle = Math.random() < 0.5 ? "#000000" : "#FFFFFF";
    ctx.beginPath();
    ctx.arc(sx, sy, size, 0, Math.PI * 2);
    ctx.fill();
  }

  lastX = x;
  lastY = y;
  lastTime = now;
}



function drawScatter(x, y) {
  const pixelSize = Math.max(2, currentBrushSize / 3); // slightly smaller pixels = denser coverage
  const radius = currentBrushSize / 2;

  // Align to pixel grid
  const gridX = Math.floor(x / pixelSize) * pixelSize;
  const gridY = Math.floor(y / pixelSize) * pixelSize;

  for (let px = gridX - radius; px <= gridX + radius; px += pixelSize) {
    for (let py = gridY - radius; py <= gridY + radius; py += pixelSize) {
      const dx = px - x;
      const dy = py - y;

      // Only draw inside a circle (for round brush shape)
      if (dx * dx + dy * dy <= radius * radius) {
        ctx.fillStyle = currentColor;
        ctx.fillRect(px, py, pixelSize, pixelSize);
      }
    }
  }
}




function drawHalftone(x, y) {
  if (drawHalftone.prevX === undefined || drawHalftone.prevY === undefined) {
    drawHalftone.prevX = x;
    drawHalftone.prevY = y;
    return;
  }
  const dx = x - drawHalftone.prevX;
  const dy = y - drawHalftone.prevY;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const strokes = Math.max(5, Math.min(50, Math.floor(dist * 2)));
  for (let i = 0; i < strokes; i++) {
    const t = i / strokes;
    const px = drawHalftone.prevX + dx * t;
    const py = drawHalftone.prevY + dy * t;
    const jitter = Math.random() * (dist / 3 + 1);
    const jx = px + (Math.random() - 0.5) * jitter - currentBrushSize / 2;
    const jy = py + (Math.random() - 0.5) * jitter - currentBrushSize / 2;
    const color = Math.random() < 0.5 ? "#000000" : "#FFFFFF";
    ctx.fillStyle = color;
    ctx.fillRect(jx, jy, currentBrushSize, currentBrushSize);
  }
  drawHalftone.prevX = x;
  drawHalftone.prevY = y;
}


function resetHalftone() {
  drawHalftone.prevX = undefined;
  drawHalftone.prevY = undefined;
}

function drawNoise(x, y) {
  const baseWidth = currentBrushSize;
  // scale height slower: grows with sqrt so it feels more subtle
  const baseHeight = Math.max(2, Math.sqrt(currentBrushSize) * 0.8);
  const layers = 5;

  for (let i = 0; i < layers; i++) {
    // offsets also grow slower (half the brush size instead of full)
    const offsetX = (Math.random() - 0.5) * (currentBrushSize * 0.5);
    const offsetY = (Math.random() - 0.5) * (currentBrushSize * 0.5);

    // widths scale but with smaller randomness
    const width1 = baseWidth + Math.random() * (baseWidth * 0.15);
    const height1 = baseHeight;

    const width2 = Math.random() * (baseWidth * 0.6);
    const height2 = baseHeight;

    ctx.fillStyle = currentColor;

    // Center first rectangle
    ctx.fillRect(
      x + offsetX - width1 / 2,
      y + offsetY - height1 / 2,
      width1,
      height1
    );

    // Center second rectangle (below first)
    ctx.fillRect(
      x + offsetX - width2 / 2,
      y + offsetY + baseHeight - height2 / 2,
      width2,
      height2
    );
  }
}


function drawGlitch(x, y) {
  ctx.strokeStyle = currentColor;
  ctx.beginPath();
  for (let i = 0; i < 20; i++) {
    const angle = 0.3 * i;
    const radius = currentBrushSize * 0.2 * i;
    ctx.lineTo(x + radius * Math.cos(angle), y + radius * Math.sin(angle));
  }
  ctx.stroke();
}

function drawPixel(x, y) {
  const size = currentBrushSize;
  const chunk = Math.max(2, Math.floor(size / 4));

  // Offset to center the brush around the cursor
  const offset = Math.floor(size / 2);
  const startX = x - offset;
  const startY = y - offset;

  for (let i = 0; i < size; i += chunk) {
    for (let j = 0; j < size; j += chunk) {
      const color = Math.random() < 0.5 ? "#000000" : "#FFFFFF";
      ctx.fillStyle = color;
      ctx.fillRect(startX + i, startY + j, chunk, chunk);
    }
  }
}



function drawSpiral(x, y) {
  const r = currentBrushSize * 2;
  const img = ctx.getImageData(x - r, y - r, r * 2, r * 2);
  const data = img.data;
  const cx = img.width / 2, cy = img.height / 2;

  for (let py = 0; py < img.height; py++) {
    for (let px = 0; px < img.width; px++) {
      const dx = px - cx;
      const dy = py - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);

      // Only apply spiral inside circular brush area
      if (dist <= r) {
        const angle = Math.atan2(dy, dx) + dist / (r * 5); // spiral amount scales with brush size
        const sx = Math.round(cx + Math.cos(angle) * dist);
        const sy = Math.round(cy + Math.sin(angle) * dist);

        if (sx >= 0 && sx < img.width && sy >= 0 && sy < img.height) {
          const idx = (py * img.width + px) * 4;
          const sidx = (sy * img.width + sx) * 4;

          data[idx] = data[sidx];
          data[idx + 1] = data[sidx + 1];
          data[idx + 2] = data[sidx + 2];
          // Keep alpha unchanged
        }
      }
    }
  }

  ctx.putImageData(img, x - r, y - r);
}


function drawCross(x, y) {
  ctx.save();
  ctx.strokeStyle = currentColor;
  ctx.lineWidth = Math.max(1, currentBrushSize / 4); // Scales line width with brush size

  ctx.beginPath();
  // Horizontal line across the whole canvas
  ctx.moveTo(0, y);
  ctx.lineTo(ctx.canvas.width, y);

  // Vertical line across the whole canvas
  ctx.moveTo(x, 0);
  ctx.lineTo(x, ctx.canvas.height);

  ctx.stroke();
  ctx.restore();
}


function drawDisplace(x, y) {
  const r = currentBrushSize;
  const img = ctx.getImageData(x - r, y - r, r * 2, r * 2);
  const data = img.data;

  const frequency = r / 4;         // Controls wave frequency
  const amplitude = r / 8;         // Controls displacement strength

  for (let py = 0; py < img.height; py++) {
    for (let px = 0; px < img.width; px++) {
      const idx = (py * img.width + px) * 4;

      // Displacement amount scales with brush size
      const dx = Math.sin(py / frequency) * amplitude;
      const dy = Math.cos(px / frequency) * amplitude;

      const sx = Math.min(img.width - 1, Math.max(0, px + dx));
      const sy = Math.min(img.height - 1, Math.max(0, py + dy));
      const sidx = (Math.round(sy) * img.width + Math.round(sx)) * 4;

      data[idx] = data[sidx];
      data[idx + 1] = data[sidx + 1];
      data[idx + 2] = data[sidx + 2];
      // Leave alpha as is
    }
  }

  ctx.putImageData(img, x - r, y - r);
}

function drawSpeed(x, y) {
  const r = currentBrushSize * 2;
  const img = ctx.getImageData(x - r, y - r, r * 2, r * 2);
  const data = img.data;
  for (let py = 0; py < img.height; py++) {
    if (Math.random() < 0.1) {
      const shift = Math.floor((Math.random() - 0.5) * 20);
      for (let px = 0; px < img.width; px++) {
        const idx = (py * img.width + px) * 4;
        const sx = Math.min(img.width - 1, Math.max(0, px + shift));
        const sidx = (py * img.width + sx) * 4;
        data[idx] = data[sidx];
        data[idx + 1] = data[sidx + 1];
        data[idx + 2] = data[sidx + 2];
      }
    }
  }
  ctx.putImageData(img, x - r, y - r);
}

function drawRipple(x, y) {
  const r = currentBrushSize * 2; // Defines area affected
  const img = ctx.getImageData(x - r, y - r, r * 2, r * 2);
  const data = img.data;

  // Dynamic parameters based on currentBrushSize
  const wavelength = currentBrushSize / 1.5;     // Controls wave tightness
  const amplitude = currentBrushSize / 6;        // Controls how much displacement

  for (let py = 0; py < img.height; py++) {
    for (let px = 0; px < img.width; px++) {
      const idx = (py * img.width + px) * 4;

      const dx = px - r, dy = py - r;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;

      const offset = Math.sin(dist / wavelength) * amplitude;

      const sx = Math.min(img.width - 1, Math.max(0, px + dx * offset / dist));
      const sy = Math.min(img.height - 1, Math.max(0, py + dy * offset / dist));

      const sidx = (Math.round(sy) * img.width + Math.round(sx)) * 4;

      data[idx] = data[sidx];
      data[idx + 1] = data[sidx + 1];
      data[idx + 2] = data[sidx + 2];
      // Alpha stays unchanged
    }
  }

  ctx.putImageData(img, x - r, y - r);
}


function drawSmear(x, y) {
  if (lastX == null || lastY == null) return;

  const dx = x - lastX;
  const dy = y - lastY;
  const len = Math.sqrt(dx * dx + dy * dy);
  const steps = Math.max(4, len / 2);

  const sampleWidth = Math.max(1, Math.abs(dx));
  const sampleHeight = Math.max(1, Math.abs(dy));
  const sx = Math.floor(lastX);
  const sy = Math.floor(lastY);

  // Get a narrow strip from the last position
  const img = ctx.getImageData(sx, sy, sampleWidth, sampleHeight);

  // Modify the pixel data to remove gray & enforce black/white
  const data = img.data;
  for (let i = 0; i < data.length; i += 4) {
    const avg = (data[i] + data[i+1] + data[i+2]) / 3;
    const isWhite = avg > 128;
    data[i] = data[i+1] = data[i+2] = isWhite ? 255 : 0; // Binarize
    data[i+3] = 255; // Fully opaque
  }

  // Store modified version in temp canvas once
  const tempCanvas = document.createElement("canvas");
  tempCanvas.width = sampleWidth;
  tempCanvas.height = sampleHeight;
  const tempCtx = tempCanvas.getContext("2d");
  tempCtx.putImageData(img, 0, 0);

  for (let i = 0; i < steps; i++) {
    const t = i / steps;

    let px = lastX + dx * t;
    let py = lastY + dy * t;

    // Chaotic jitter — increase for more glitch
    const jitter = 3;
    px += (Math.random() - 0.5) * jitter;
    py += (Math.random() - 0.5) * jitter;

    // No alpha, no flipping = bolder marks
    ctx.globalAlpha = 1.0;
    ctx.drawImage(tempCanvas, px, py);
  }
}


function drawBucket(x, y) {
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data;

  const width = canvas.width;
  const height = canvas.height;

  // Get target pixel index
  const targetIndex = (Math.floor(y) * width + Math.floor(x)) * 4;

  // Convert target color to pure black or white
  const targetGray = data[targetIndex] * 0.299 + data[targetIndex + 1] * 0.587 + data[targetIndex + 2] * 0.114;
  const targetValue = targetGray > 127 ? 255 : 0;

  // Determine fill value from currentColor
  const fillValue = currentColor === '#000000' ? 0 : 255;

  // If trying to fill with same value → do nothing
  if (targetValue === fillValue) return;

  // Flood fill
  const visited = new Uint8Array(width * height);
  const stack = [Math.floor(x) + Math.floor(y) * width];

  while (stack.length > 0) {
    const pos = stack.pop();
    if (visited[pos]) continue;
    visited[pos] = 1;

    const px = pos % width;
    const py = Math.floor(pos / width);
    if (px < 0 || px >= width || py < 0 || py >= height) continue;

    const idx = pos * 4;

    // Convert this pixel to black/white and check match
    const gray = data[idx] * 0.299 + data[idx + 1] * 0.587 + data[idx + 2] * 0.114;
    const val = gray > 127 ? 255 : 0;

    if (val !== targetValue) continue;

    // Fill with chosen value
    data[idx] = data[idx + 1] = data[idx + 2] = fillValue;
    data[idx + 3] = 255;

    // Push neighbors
    if (px > 0) stack.push(pos - 1);
    if (px < width - 1) stack.push(pos + 1);
    if (py > 0) stack.push(pos - width);
    if (py < height - 1) stack.push(pos + width);
  }

  ctx.putImageData(imageData, 0, 0);
}



function drawBucketHalf(x, y) {
  const patternScale = currentBrushSize / 8;      // Controls pattern size
  const spacing = 8 * patternScale;               // Scales dot spacing
  const radius = 2 * patternScale;                // Scales dot size

  const halfBrush = currentBrushSize * 1.5;       // Controls brush area

  ctx.save();
  ctx.fillStyle = currentColor;

  // Square brush area
  for (let yy = -halfBrush; yy <= halfBrush; yy += spacing) {
    for (let xx = -halfBrush; xx <= halfBrush; xx += spacing) {
      ctx.beginPath();
      ctx.arc(x + xx, y + yy, radius, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  ctx.restore();
}



// --- Main draw ---
function startDrawing(e) {
  saveState();
  isDrawing = true;
  const rect = canvas.getBoundingClientRect();
  lastX = (e.clientX - rect.left) * (canvas.width / rect.width);
  lastY = (e.clientY - rect.top) * (canvas.height / rect.height);
  draw(e);
}

function draw(e) {
  if (!isDrawing) return;
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (canvas.width / rect.width);
  const y = (e.clientY - rect.top) * (canvas.height / rect.height);
  
  switch(currentBrush) {
    case 'smooth': drawSmooth(x, y); break;
    case 'soft': drawSoft(x, y); break;
    case 'texture': drawTexture(x, y); break;
    case 'scatter': drawScatter(x, y); break;
    case 'halftone': drawHalftone(x, y); break;
    case 'noise': drawNoise(x, y); break;
    case 'glitch': drawGlitch(x, y); break;
    case 'pixel': drawPixel(x, y); break;
    case 'spiral': drawSpiral(x, y); break;
    case 'cross': drawCross(x, y); break;
    case 'displace': drawDisplace(x, y); break;
    case 'speed': drawSpeed(x, y); break;
    case 'ripple': drawRipple(x, y); break;
    case 'smear': drawSmear(x, y); break;
    case 'bucket': drawBucket(x, y); break;
    case 'bucketHalf': drawBucketHalf(x, y); break;
    case 'socrates': socrates(e); break;
    case 'plato': plato(x, y); break;
    case 'aristotle': aristotle(x, y); break;
    case 'descartes': descartes(e); break;
    case 'nietzsche': Nietzsche(x, y); break;
    case 'camus': /* add camus function logic here */ break;
  }
  lastX = x; 
  lastY = y;
}

function stopDrawing() { 
  isDrawing = false; 
  lastX = lastY = 0; 
  resetHalftone();
}

canvas.addEventListener('mousedown', startDrawing);
canvas.addEventListener('mousemove', draw);
canvas.addEventListener('mouseup', stopDrawing);
canvas.addEventListener('mouseout', stopDrawing);

// Utils
function clearCanvas() { 
  saveState(); 
  ctx.fillStyle = 'white'; 
  ctx.fillRect(0, 0, canvas.width, canvas.height); 
}

function invertAndThreshold() { 
  const img = ctx.getImageData(0, 0, canvas.width, canvas.height); 
  const d = img.data; 
  for(let i = 0; i < d.length; i += 4) {
    const g = d[i] * 0.3 + d[i + 1] * 0.6 + d[i + 2] * 0.1;
    const t = g > 127 ? 0 : 255;
    d[i] = d[i + 1] = d[i + 2] = t;
  } 
  ctx.putImageData(img, 0, 0);
} 

function saveImage() {
  // Create a temporary canvas to apply threshold
  const tempCanvas = document.createElement('canvas');
  const tempCtx = tempCanvas.getContext('2d');

  tempCanvas.width = canvas.width;
  tempCanvas.height = canvas.height;

  // Copy current image to temp canvas
  tempCtx.drawImage(canvas, 0, 0);

  // Get image data from temp canvas
  const img = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
  const d = img.data;

  // Apply threshold (black/white only, no inversion)
  for (let i = 0; i < d.length; i += 4) {
    const g = d[i] * 0.3 + d[i + 1] * 0.6 + d[i + 2] * 0.1;
    const t = g > 127 ? 255 : 0;
    d[i] = d[i + 1] = d[i + 2] = t;
  }

  // Put processed image back into temp canvas
  tempCtx.putImageData(img, 0, 0);

  // Generate unique filename
  const uniqueId = Date.now(); // timestamp ensures uniqueness
  const filename = `AvocadoPaint_${uniqueId}.png`;

  // Save as PNG
  const a = document.createElement('a');
  a.download = filename;
  a.href = tempCanvas.toDataURL();
  a.click();
}

// --- Keyboard Shortcuts (single letters) ---
document.addEventListener('keydown', function (e) {
  // Ignore if typing in an input/textarea
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

  switch (e.key.toLowerCase()) {
    case 'u': // Undo
      e.preventDefault();
      undo();
      break;

    case 's': // Save
      e.preventDefault();
      saveImage();
      break;

    case 'i': // Invert
      e.preventDefault();
      invertAndThreshold();
      break;

    case 'backspace': // Clear canvas
      e.preventDefault();
      clearCanvas();
      break;
  }

  // Handle brush size with arrow keys
  switch (e.key) {
    case 'ArrowUp':
      e.preventDefault();
      brushSizeSlider.value = Math.min(200, parseInt(brushSizeSlider.value) + 10);
      brushSizeSlider.dispatchEvent(new Event('input'));
      break;

    case 'ArrowDown':
      e.preventDefault();
      brushSizeSlider.value = Math.max(1, parseInt(brushSizeSlider.value) - 10);
      brushSizeSlider.dispatchEvent(new Event('input'));
      break;
  }
});

function importImage() {
  document.getElementById('imageInput').click();
}

document.getElementById('imageInput').addEventListener('change', function(e) {
  const file = e.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function(event) {
    const img = new Image();
    img.onload = function() {
      // Draw image scaled to canvas
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');

      tempCanvas.width = canvas.width;
      tempCanvas.height = canvas.height;

      // Draw image scaled to fit canvas
      tempCtx.drawImage(img, 0, 0, canvas.width, canvas.height);

      // Get image data and apply halftone
      const imageData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const dotSpacing = 6;
      const dotSize = 3;

      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, canvas.width, canvas.height); // Clear canvas first

      for (let y = 0; y < canvas.height; y += dotSpacing) {
        for (let x = 0; x < canvas.width; x += dotSpacing) {
          const idx = (y * canvas.width + x) * 4;
          const r = data[idx], g = data[idx + 1], b = data[idx + 2];
          const brightness = 0.3 * r + 0.6 * g + 0.1 * b;

          const radius = (1 - brightness / 255) * dotSize;
          ctx.beginPath();
          ctx.arc(x, y, radius, 0, Math.PI * 2);
          ctx.fillStyle = '#000';
          ctx.fill();
        }
      }

      saveState(); // Allow undo
    };
    img.src = event.target.result;
  };
  reader.readAsDataURL(file);
});

// right hand side

function socrates(e) {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width / rect.width);
    const y = (e.clientY - rect.top) * (canvas.height / rect.height);
    const numLines = currentBrushSize * 20;

    ctx.globalCompositeOperation = 'source-over';
    
    for (let i = 0; i < numLines; i++) {
        // More variety in line length and width for a truly spiky look
        const lineHeight = Math.random() * (currentBrushSize * 3) + 5; 
        const lineWidth = Math.random() * 3 + 0.5;

        // The line color now uses the global currentColor variable
        const lineColor = currentColor;
        ctx.strokeStyle = lineColor; 
        ctx.lineWidth = lineWidth;
        ctx.globalAlpha = 1;

        // Random rotation for each line
        const rotation = Math.random() * Math.PI * 2; 

        ctx.save();
        ctx.translate(x, y); 
        ctx.rotate(rotation); 

        ctx.beginPath();
        ctx.moveTo(0, 0); 
        ctx.lineTo(0, lineHeight); 
        ctx.stroke();

        ctx.restore();
    }
}

function plato(x, y) {
  const glitchSize = currentBrushSize * (0.8 + Math.random() * 1.2);
  const fragments = 20 + Math.floor(Math.random() * 30); // many fragments

  for (let i = 0; i < fragments; i++) {
    const offsetX = (Math.random() - 0.5) * glitchSize * 4;
    const offsetY = (Math.random() - 0.5) * glitchSize * 4;
    const angle = Math.random() * Math.PI * 2;

    ctx.save();
    ctx.translate(x + offsetX, y + offsetY);
    ctx.rotate(angle);

    ctx.fillStyle = currentColor;
    ctx.strokeStyle = currentColor;
    ctx.globalCompositeOperation = "source-over";

    const shapeType = Math.floor(Math.random() * 5);

    if (shapeType === 0) {
      // Solid square
      const size = glitchSize * (0.4 + Math.random() * 0.6);
      ctx.fillRect(-size / 2, -size / 2, size, size);
    } else if (shapeType === 1) {
      // Tall/flat rectangle
      const w = glitchSize * (0.2 + Math.random() * 0.6);
      const h = glitchSize * (0.6 + Math.random() * 1.0);
      ctx.fillRect(-w / 2, -h / 2, w, h);
    } else if (shapeType === 2) {
      // Hollow box
      const size = glitchSize * (0.5 + Math.random() * 0.5);
      ctx.lineWidth = 2;
      ctx.strokeRect(-size / 2, -size / 2, size, size);
    } else if (shapeType === 3) {
      // Rotated diamond
      const size = glitchSize * (0.4 + Math.random() * 0.6);
      ctx.beginPath();
      ctx.moveTo(0, -size / 2);
      ctx.lineTo(size / 2, 0);
      ctx.lineTo(0, size / 2);
      ctx.lineTo(-size / 2, 0);
      ctx.closePath();
      ctx.fill();
    } else {
      // Sharp angled triangle
      const base = glitchSize * (0.3 + Math.random() * 0.7);
      const height = glitchSize * (0.4 + Math.random() * 0.8);
      ctx.beginPath();
      ctx.moveTo(0, -height / 2);
      ctx.lineTo(base / 2, height / 2);
      ctx.lineTo(-base / 2, height / 2);
      ctx.closePath();
      ctx.fill();
    }

    ctx.restore();
  }

  // Occasional chaotic spray of tiny geometric fragments
  if (Math.random() > 0.8) {
    ctx.fillStyle = currentColor;
    const tinyCount = 30 + Math.floor(Math.random() * 30);
    for (let i = 0; i < tinyCount; i++) {
      const size = 1 + Math.random() * 4;
      ctx.fillRect(
        x + (Math.random() - 0.5) * glitchSize * 6,
        y + (Math.random() - 0.5) * glitchSize * 6,
        size,
        size
      );
    }
  }

  ctx.globalCompositeOperation = "source-over";
}


function aristotle(x, y) {
  const r = currentBrushSize * 2;
  const img = ctx.getImageData(x - r, y - r, r * 2, r * 2);
  const data = img.data;

  const w = img.width;
  const h = img.height;

  // --- compute speed (self-contained memory) ---
  const now = performance.now();
  let speed = 0;
  if (aristotle.lastX !== undefined) {
    const dx = x - aristotle.lastX;
    const dy = y - aristotle.lastY;
    const dist = Math.hypot(dx, dy);
    const dt = now - aristotle.lastTime;
    speed = dt > 0 ? dist / dt : 0;
  }
  aristotle.lastX = x;
  aristotle.lastY = y;
  aristotle.lastTime = now;

  const normSpeed = Math.min(1, speed / 2.0);

  // helper: binarize pixel to black/white
  function bwify(idx) {
    const avg = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
    const val = avg > 128 ? 255 : 0;
    data[idx] = data[idx + 1] = data[idx + 2] = val;
  }

  // convert to B/W first
  for (let i = 0; i < data.length; i += 4) {
    bwify(i);
  }

  for (let px = 0; px < w; px++) {
    if (Math.random() < 0.15 + normSpeed * 0.4) {
      const shiftY = Math.floor((Math.random() - 0.5) * (30 + normSpeed * 80));
      const shiftX = Math.random() < 0.1 + normSpeed * 0.2
        ? Math.floor((Math.random() - 0.5) * 20)
        : 0;
      for (let py = 0; py < h; py++) {
        const idx = (py * w + px) * 4;
        const sy = Math.min(h - 1, Math.max(0, py + shiftY));
        const sx = Math.min(w - 1, Math.max(0, px + shiftX));
        const sidx = (sy * w + sx) * 4;
        data[idx] = data[idx + 1] = data[idx + 2] = data[sidx];
      }
    }

    if (Math.random() < 0.1 + normSpeed * 0.3) {
      const streakLen = 5 + Math.floor(Math.random() * (20 + normSpeed * 60));
      for (let py = 0; py < h - streakLen; py++) {
        const idx = (py * w + px) * 4;
        const sidx = ((py + streakLen) * w + px) * 4;
        data[idx] = data[idx + 1] = data[idx + 2] = data[sidx];
      }
    }

    if (Math.random() < 0.05 + normSpeed * 0.2) {
      for (let py = 0; py < h; py++) {
        const idx = (py * w + px) * 4;
        const val = data[idx] > 128 ? 0 : 255;
        data[idx] = data[idx + 1] = data[idx + 2] = val;
      }
    }

    if (Math.random() < 0.04 + normSpeed * 0.15) {
      for (let py = 0; py < h; py++) {
        const idx = (py * w + px) * 4;
        if (Math.random() < 0.3 + normSpeed * 0.4) {
          const val = Math.random() < 0.5 ? 0 : 255;
          data[idx] = data[idx + 1] = data[idx + 2] = val;
        }
      }
    }
  }

  if (Math.random() < 0.1 + normSpeed * 0.3) {
    const stripWidth = 3 + Math.floor(Math.random() * (10 + normSpeed * 20));
    const srcX = Math.floor(Math.random() * (w - stripWidth));
    const dstX = Math.floor(Math.random() * (w - stripWidth));
    for (let py = 0; py < h; py++) {
      for (let dx = 0; dx < stripWidth; dx++) {
        const srcIdx = (py * w + (srcX + dx)) * 4;
        const dstIdx = (py * w + (dstX + dx)) * 4;
        data[dstIdx] = data[dstIdx + 1] = data[dstIdx + 2] = data[srcIdx];
      }
    }
  }

  if (Math.random() < 0.03 + normSpeed * 0.1) {
    const cx = w / 2;
    const cy = h / 2;
    const swirlStrength = (0.2 + Math.random() * 0.6) * (1 + normSpeed * 2);

    const copy = new Uint8ClampedArray(data);
    for (let py = 0; py < h; py++) {
      for (let px2 = 0; px2 < w; px2++) {
        const dx = px2 - cx;
        const dy = py - cy;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx) + swirlStrength * Math.exp(-dist / 25);

        const sx = Math.floor(cx + dist * Math.cos(angle));
        const sy = Math.floor(cy + dist * Math.sin(angle));

        if (sx >= 0 && sx < w && sy >= 0 && sy < h) {
          const idx = (py * w + px2) * 4;
          const sidx = (sy * w + sx) * 4;
          data[idx] = data[idx + 1] = data[idx + 2] = copy[sidx];
        }
      }
    }
  }

  ctx.putImageData(img, x - r, y - r);
}



function descartes(e) {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width / rect.width);
    const y = (e.clientY - rect.top) * (canvas.height / rect.height);

    // initialize last position/time if not set
    if (descartes.lastX === undefined || descartes.lastY === undefined) {
        descartes.lastX = x;
        descartes.lastY = y;
        descartes.lastTime = performance.now();
        return;
    }

    // direction vector
    const dx = x - descartes.lastX;
    const dy = y - descartes.lastY;
    const dist = Math.hypot(dx, dy);
    const angle = Math.atan2(dy, dx);

    // speed (px per ms)
    const now = performance.now();
    const dt = now - descartes.lastTime;
    const speed = dt > 0 ? dist / dt : 0;

    // update last position/time
    descartes.lastX = x;
    descartes.lastY = y;
    descartes.lastTime = now;

    // brush parameters with speed influence
    const steps = 40;
    const amplitude = currentBrushSize * (1 + speed * 0.2); // taller when faster
    const frequency = 2 + speed * 0.05; // more cycles when faster
    const sharpness = 3;

    ctx.globalCompositeOperation = 'source-over';
    ctx.strokeStyle = currentColor;
    ctx.lineWidth = 2;
    ctx.globalAlpha = 1;

    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);

    ctx.beginPath();
    for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const raw = Math.sin(t * Math.PI * 2 * frequency);
        const s = Math.sign(raw) * Math.pow(Math.abs(raw), sharpness);
        const px = (t - 0.5) * currentBrushSize * 20;
        const py = s * amplitude;

        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
    }
    ctx.stroke();

    ctx.restore();
}


function Nietzsche(x, y) {
  const r = currentBrushSize * 4; // half the side length
  const size = r * 2;

  // create an offscreen pattern canvas
  const patternCanvas = document.createElement("canvas");
  patternCanvas.width = size;
  patternCanvas.height = size;
  const pctx = patternCanvas.getContext("2d");

  // make spacing scale with brush size
  const spacing = Math.max(4, currentBrushSize * 2);
  pctx.fillStyle = "#fff";
  pctx.fillRect(0, 0, size, size);
  pctx.strokeStyle = "#000";
  pctx.lineWidth = Math.max(1, currentBrushSize * 0.2);

  // draw diagonals for chain-link pattern
  for (let i = -size; i < size * 2; i += spacing) {
    pctx.beginPath();
    pctx.moveTo(i, 0);
    pctx.lineTo(i + size, size);
    pctx.stroke();

    pctx.beginPath();
    pctx.moveTo(i, size);
    pctx.lineTo(i + size, 0);
    pctx.stroke();
  }

  // turn it into a repeating pattern
  const pattern = ctx.createPattern(patternCanvas, "repeat");

  // fill a square onto the main canvas at brush location
  ctx.save();
  ctx.globalCompositeOperation = "source-over";
  ctx.fillStyle = pattern;
  ctx.fillRect(x - r, y - r, size, size);
  ctx.restore();
}


updateBrushPreview();
</script>
</body>
</html>
